schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""
whether this query should be cached (Hasura Cloud only)
"""
directive @cached(
  """
  measured in seconds
  """
  ttl: Int! = 60

  """
  refresh the cache entry
  """
  refresh: Boolean! = false
) on QUERY

input Auth0Input {
  email: String!
  emailVerified: String!
  name: String!
  phone: String!
  phoneVerified: String!
  picture: String!
  username: String!
}

type Auth0Output {
  accessToken: String!
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """
  does the column match the given case-insensitive pattern
  """
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """
  does the column match the given pattern
  """
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """
  does the column NOT match the given case-insensitive pattern
  """
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """
  does the column NOT match the given pattern
  """
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """
  does the column NOT match the given SQL regular expression
  """
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """
  does the column match the given SQL regular expression
  """
  _similar: String
}

"""
columns and relationships of "activity_logins"
"""
type activityLogin {
  id: Int!
  ipAddress: String!
  timestamp: timestamptz!

  """
  An object relationship
  """
  user: user!
  userId: Int!
}

"""
aggregated selection of "activity_logins"
"""
type activityLogin_aggregate {
  aggregate: activityLogin_aggregate_fields
  nodes: [activityLogin!]!
}

"""
aggregate fields of "activity_logins"
"""
type activityLogin_aggregate_fields {
  avg: activityLogin_avg_fields
  count(columns: [activityLogin_select_column!], distinct: Boolean): Int!
  max: activityLogin_max_fields
  min: activityLogin_min_fields
  stddev: activityLogin_stddev_fields
  stddev_pop: activityLogin_stddev_pop_fields
  stddev_samp: activityLogin_stddev_samp_fields
  sum: activityLogin_sum_fields
  var_pop: activityLogin_var_pop_fields
  var_samp: activityLogin_var_samp_fields
  variance: activityLogin_variance_fields
}

"""
order by aggregate values of table "activity_logins"
"""
input activityLogin_aggregate_order_by {
  avg: activityLogin_avg_order_by
  count: order_by
  max: activityLogin_max_order_by
  min: activityLogin_min_order_by
  stddev: activityLogin_stddev_order_by
  stddev_pop: activityLogin_stddev_pop_order_by
  stddev_samp: activityLogin_stddev_samp_order_by
  sum: activityLogin_sum_order_by
  var_pop: activityLogin_var_pop_order_by
  var_samp: activityLogin_var_samp_order_by
  variance: activityLogin_variance_order_by
}

"""
input type for inserting array relation for remote table "activity_logins"
"""
input activityLogin_arr_rel_insert_input {
  data: [activityLogin_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: activityLogin_on_conflict
}

"""
aggregate avg on columns
"""
type activityLogin_avg_fields {
  id: Float
  userId: Float
}

"""
order by avg() on columns of table "activity_logins"
"""
input activityLogin_avg_order_by {
  id: order_by
  userId: order_by
}

"""
Boolean expression to filter rows from the table "activity_logins". All fields are combined with a logical 'AND'.
"""
input activityLogin_bool_exp {
  _and: [activityLogin_bool_exp!]
  _not: activityLogin_bool_exp
  _or: [activityLogin_bool_exp!]
  id: Int_comparison_exp
  ipAddress: String_comparison_exp
  timestamp: timestamptz_comparison_exp
  user: user_bool_exp
  userId: Int_comparison_exp
}

"""
unique or primary key constraints on table "activity_logins"
"""
enum activityLogin_constraint {
  """
  unique or primary key constraint
  """
  activity_logins_id_key

  """
  unique or primary key constraint
  """
  activity_logins_pkey

  """
  unique or primary key constraint
  """
  activity_logins_user_id_timestamp_key
}

"""
input type for incrementing numeric columns in table "activity_logins"
"""
input activityLogin_inc_input {
  id: Int
  userId: Int
}

"""
input type for inserting data into table "activity_logins"
"""
input activityLogin_insert_input {
  id: Int
  ipAddress: String
  timestamp: timestamptz
  user: user_obj_rel_insert_input
  userId: Int
}

"""
aggregate max on columns
"""
type activityLogin_max_fields {
  id: Int
  ipAddress: String
  timestamp: timestamptz
  userId: Int
}

"""
order by max() on columns of table "activity_logins"
"""
input activityLogin_max_order_by {
  id: order_by
  ipAddress: order_by
  timestamp: order_by
  userId: order_by
}

"""
aggregate min on columns
"""
type activityLogin_min_fields {
  id: Int
  ipAddress: String
  timestamp: timestamptz
  userId: Int
}

"""
order by min() on columns of table "activity_logins"
"""
input activityLogin_min_order_by {
  id: order_by
  ipAddress: order_by
  timestamp: order_by
  userId: order_by
}

"""
response of any mutation on the table "activity_logins"
"""
type activityLogin_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [activityLogin!]!
}

"""
on conflict condition type for table "activity_logins"
"""
input activityLogin_on_conflict {
  constraint: activityLogin_constraint!
  update_columns: [activityLogin_update_column!]! = []
  where: activityLogin_bool_exp
}

"""
Ordering options when selecting data from "activity_logins".
"""
input activityLogin_order_by {
  id: order_by
  ipAddress: order_by
  timestamp: order_by
  user: user_order_by
  userId: order_by
}

"""
primary key columns input for table: activityLogin
"""
input activityLogin_pk_columns_input {
  id: Int!
}

"""
select columns of table "activity_logins"
"""
enum activityLogin_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  ipAddress

  """
  column name
  """
  timestamp

  """
  column name
  """
  userId
}

"""
input type for updating data in table "activity_logins"
"""
input activityLogin_set_input {
  id: Int
  ipAddress: String
  timestamp: timestamptz
  userId: Int
}

"""
aggregate stddev on columns
"""
type activityLogin_stddev_fields {
  id: Float
  userId: Float
}

"""
order by stddev() on columns of table "activity_logins"
"""
input activityLogin_stddev_order_by {
  id: order_by
  userId: order_by
}

"""
aggregate stddev_pop on columns
"""
type activityLogin_stddev_pop_fields {
  id: Float
  userId: Float
}

"""
order by stddev_pop() on columns of table "activity_logins"
"""
input activityLogin_stddev_pop_order_by {
  id: order_by
  userId: order_by
}

"""
aggregate stddev_samp on columns
"""
type activityLogin_stddev_samp_fields {
  id: Float
  userId: Float
}

"""
order by stddev_samp() on columns of table "activity_logins"
"""
input activityLogin_stddev_samp_order_by {
  id: order_by
  userId: order_by
}

"""
aggregate sum on columns
"""
type activityLogin_sum_fields {
  id: Int
  userId: Int
}

"""
order by sum() on columns of table "activity_logins"
"""
input activityLogin_sum_order_by {
  id: order_by
  userId: order_by
}

"""
update columns of table "activity_logins"
"""
enum activityLogin_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  ipAddress

  """
  column name
  """
  timestamp

  """
  column name
  """
  userId
}

"""
aggregate var_pop on columns
"""
type activityLogin_var_pop_fields {
  id: Float
  userId: Float
}

"""
order by var_pop() on columns of table "activity_logins"
"""
input activityLogin_var_pop_order_by {
  id: order_by
  userId: order_by
}

"""
aggregate var_samp on columns
"""
type activityLogin_var_samp_fields {
  id: Float
  userId: Float
}

"""
order by var_samp() on columns of table "activity_logins"
"""
input activityLogin_var_samp_order_by {
  id: order_by
  userId: order_by
}

"""
aggregate variance on columns
"""
type activityLogin_variance_fields {
  id: Float
  userId: Float
}

"""
order by variance() on columns of table "activity_logins"
"""
input activityLogin_variance_order_by {
  id: order_by
  userId: order_by
}

"""
columns and relationships of "courses"
"""
type course {
  content: String!
  createdAt: timestamptz!
  createdById: Int!
  id: Int!
  premium: Boolean!
  price: numeric!
  sku: String!
  slug: String!
  status: String!
  summary: String!
  title: String!
  updatedAt: timestamptz!
  updatedById: Int!

  """
  An object relationship
  """
  user: user!

  """
  An object relationship
  """
  userByCreatedById: user!
}

"""
aggregated selection of "courses"
"""
type course_aggregate {
  aggregate: course_aggregate_fields
  nodes: [course!]!
}

"""
aggregate fields of "courses"
"""
type course_aggregate_fields {
  avg: course_avg_fields
  count(columns: [course_select_column!], distinct: Boolean): Int!
  max: course_max_fields
  min: course_min_fields
  stddev: course_stddev_fields
  stddev_pop: course_stddev_pop_fields
  stddev_samp: course_stddev_samp_fields
  sum: course_sum_fields
  var_pop: course_var_pop_fields
  var_samp: course_var_samp_fields
  variance: course_variance_fields
}

"""
order by aggregate values of table "courses"
"""
input course_aggregate_order_by {
  avg: course_avg_order_by
  count: order_by
  max: course_max_order_by
  min: course_min_order_by
  stddev: course_stddev_order_by
  stddev_pop: course_stddev_pop_order_by
  stddev_samp: course_stddev_samp_order_by
  sum: course_sum_order_by
  var_pop: course_var_pop_order_by
  var_samp: course_var_samp_order_by
  variance: course_variance_order_by
}

"""
input type for inserting array relation for remote table "courses"
"""
input course_arr_rel_insert_input {
  data: [course_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: course_on_conflict
}

"""
aggregate avg on columns
"""
type course_avg_fields {
  createdById: Float
  id: Float
  price: Float
  updatedById: Float
}

"""
order by avg() on columns of table "courses"
"""
input course_avg_order_by {
  createdById: order_by
  id: order_by
  price: order_by
  updatedById: order_by
}

"""
Boolean expression to filter rows from the table "courses". All fields are combined with a logical 'AND'.
"""
input course_bool_exp {
  _and: [course_bool_exp!]
  _not: course_bool_exp
  _or: [course_bool_exp!]
  content: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  createdById: Int_comparison_exp
  id: Int_comparison_exp
  premium: Boolean_comparison_exp
  price: numeric_comparison_exp
  sku: String_comparison_exp
  slug: String_comparison_exp
  status: String_comparison_exp
  summary: String_comparison_exp
  title: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
  updatedById: Int_comparison_exp
  user: user_bool_exp
  userByCreatedById: user_bool_exp
}

"""
unique or primary key constraints on table "courses"
"""
enum course_constraint {
  """
  unique or primary key constraint
  """
  courses_pkey

  """
  unique or primary key constraint
  """
  courses_sku_key

  """
  unique or primary key constraint
  """
  courses_slug_key

  """
  unique or primary key constraint
  """
  courses_title_key
}

"""
input type for incrementing numeric columns in table "courses"
"""
input course_inc_input {
  createdById: Int
  id: Int
  price: numeric
  updatedById: Int
}

"""
input type for inserting data into table "courses"
"""
input course_insert_input {
  content: String
  createdAt: timestamptz
  createdById: Int
  id: Int
  premium: Boolean
  price: numeric
  sku: String
  slug: String
  status: String
  summary: String
  title: String
  updatedAt: timestamptz
  updatedById: Int
  user: user_obj_rel_insert_input
  userByCreatedById: user_obj_rel_insert_input
}

"""
aggregate max on columns
"""
type course_max_fields {
  content: String
  createdAt: timestamptz
  createdById: Int
  id: Int
  price: numeric
  sku: String
  slug: String
  status: String
  summary: String
  title: String
  updatedAt: timestamptz
  updatedById: Int
}

"""
order by max() on columns of table "courses"
"""
input course_max_order_by {
  content: order_by
  createdAt: order_by
  createdById: order_by
  id: order_by
  price: order_by
  sku: order_by
  slug: order_by
  status: order_by
  summary: order_by
  title: order_by
  updatedAt: order_by
  updatedById: order_by
}

"""
aggregate min on columns
"""
type course_min_fields {
  content: String
  createdAt: timestamptz
  createdById: Int
  id: Int
  price: numeric
  sku: String
  slug: String
  status: String
  summary: String
  title: String
  updatedAt: timestamptz
  updatedById: Int
}

"""
order by min() on columns of table "courses"
"""
input course_min_order_by {
  content: order_by
  createdAt: order_by
  createdById: order_by
  id: order_by
  price: order_by
  sku: order_by
  slug: order_by
  status: order_by
  summary: order_by
  title: order_by
  updatedAt: order_by
  updatedById: order_by
}

"""
response of any mutation on the table "courses"
"""
type course_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [course!]!
}

"""
on conflict condition type for table "courses"
"""
input course_on_conflict {
  constraint: course_constraint!
  update_columns: [course_update_column!]! = []
  where: course_bool_exp
}

"""
Ordering options when selecting data from "courses".
"""
input course_order_by {
  content: order_by
  createdAt: order_by
  createdById: order_by
  id: order_by
  premium: order_by
  price: order_by
  sku: order_by
  slug: order_by
  status: order_by
  summary: order_by
  title: order_by
  updatedAt: order_by
  updatedById: order_by
  user: user_order_by
  userByCreatedById: user_order_by
}

"""
primary key columns input for table: course
"""
input course_pk_columns_input {
  id: Int!
}

"""
select columns of table "courses"
"""
enum course_select_column {
  """
  column name
  """
  content

  """
  column name
  """
  createdAt

  """
  column name
  """
  createdById

  """
  column name
  """
  id

  """
  column name
  """
  premium

  """
  column name
  """
  price

  """
  column name
  """
  sku

  """
  column name
  """
  slug

  """
  column name
  """
  status

  """
  column name
  """
  summary

  """
  column name
  """
  title

  """
  column name
  """
  updatedAt

  """
  column name
  """
  updatedById
}

"""
input type for updating data in table "courses"
"""
input course_set_input {
  content: String
  createdAt: timestamptz
  createdById: Int
  id: Int
  premium: Boolean
  price: numeric
  sku: String
  slug: String
  status: String
  summary: String
  title: String
  updatedAt: timestamptz
  updatedById: Int
}

"""
aggregate stddev on columns
"""
type course_stddev_fields {
  createdById: Float
  id: Float
  price: Float
  updatedById: Float
}

"""
order by stddev() on columns of table "courses"
"""
input course_stddev_order_by {
  createdById: order_by
  id: order_by
  price: order_by
  updatedById: order_by
}

"""
aggregate stddev_pop on columns
"""
type course_stddev_pop_fields {
  createdById: Float
  id: Float
  price: Float
  updatedById: Float
}

"""
order by stddev_pop() on columns of table "courses"
"""
input course_stddev_pop_order_by {
  createdById: order_by
  id: order_by
  price: order_by
  updatedById: order_by
}

"""
aggregate stddev_samp on columns
"""
type course_stddev_samp_fields {
  createdById: Float
  id: Float
  price: Float
  updatedById: Float
}

"""
order by stddev_samp() on columns of table "courses"
"""
input course_stddev_samp_order_by {
  createdById: order_by
  id: order_by
  price: order_by
  updatedById: order_by
}

"""
aggregate sum on columns
"""
type course_sum_fields {
  createdById: Int
  id: Int
  price: numeric
  updatedById: Int
}

"""
order by sum() on columns of table "courses"
"""
input course_sum_order_by {
  createdById: order_by
  id: order_by
  price: order_by
  updatedById: order_by
}

"""
update columns of table "courses"
"""
enum course_update_column {
  """
  column name
  """
  content

  """
  column name
  """
  createdAt

  """
  column name
  """
  createdById

  """
  column name
  """
  id

  """
  column name
  """
  premium

  """
  column name
  """
  price

  """
  column name
  """
  sku

  """
  column name
  """
  slug

  """
  column name
  """
  status

  """
  column name
  """
  summary

  """
  column name
  """
  title

  """
  column name
  """
  updatedAt

  """
  column name
  """
  updatedById
}

"""
aggregate var_pop on columns
"""
type course_var_pop_fields {
  createdById: Float
  id: Float
  price: Float
  updatedById: Float
}

"""
order by var_pop() on columns of table "courses"
"""
input course_var_pop_order_by {
  createdById: order_by
  id: order_by
  price: order_by
  updatedById: order_by
}

"""
aggregate var_samp on columns
"""
type course_var_samp_fields {
  createdById: Float
  id: Float
  price: Float
  updatedById: Float
}

"""
order by var_samp() on columns of table "courses"
"""
input course_var_samp_order_by {
  createdById: order_by
  id: order_by
  price: order_by
  updatedById: order_by
}

"""
aggregate variance on columns
"""
type course_variance_fields {
  createdById: Float
  id: Float
  price: Float
  updatedById: Float
}

"""
order by variance() on columns of table "courses"
"""
input course_variance_order_by {
  createdById: order_by
  id: order_by
  price: order_by
  updatedById: order_by
}

scalar json

"""
Boolean expression to compare columns of type "json". All fields are combined with logical 'AND'.
"""
input json_comparison_exp {
  _eq: json
  _gt: json
  _gte: json
  _in: [json!]
  _is_null: Boolean
  _lt: json
  _lte: json
  _neq: json
  _nin: [json!]
}

"""
mutation root
"""
type mutation_root {
  """
  delete single row from the table: "activity_logins"
  """
  activityLoginDelete(id: Int!): activityLogin

  """
  insert a single row into the table: "activity_logins"
  """
  activityLoginInsert(
    """
    the row to be inserted
    """
    object: activityLogin_insert_input!

    """
    on conflict condition
    """
    on_conflict: activityLogin_on_conflict
  ): activityLogin

  """
  update single row of the table: "activity_logins"
  """
  activityLoginUpdate(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: activityLogin_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: activityLogin_set_input
    pk_columns: activityLogin_pk_columns_input!
  ): activityLogin

  """
  delete data from the table: "activity_logins"
  """
  activityLoginsDelete(
    """
    filter the rows which have to be deleted
    """
    where: activityLogin_bool_exp!
  ): activityLogin_mutation_response

  """
  insert data into the table: "activity_logins"
  """
  activityLoginsInsert(
    """
    the rows to be inserted
    """
    objects: [activityLogin_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: activityLogin_on_conflict
  ): activityLogin_mutation_response

  """
  update data of the table: "activity_logins"
  """
  activityLoginsUpdate(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: activityLogin_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: activityLogin_set_input

    """
    filter the rows which have to be updated
    """
    where: activityLogin_bool_exp!
  ): activityLogin_mutation_response

  """
  delete single row from the table: "courses"
  """
  courseDelete(id: Int!): course

  """
  insert a single row into the table: "courses"
  """
  courseInsert(
    """
    the row to be inserted
    """
    object: course_insert_input!

    """
    on conflict condition
    """
    on_conflict: course_on_conflict
  ): course

  """
  update single row of the table: "courses"
  """
  courseUpdate(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: course_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: course_set_input
    pk_columns: course_pk_columns_input!
  ): course

  """
  delete data from the table: "courses"
  """
  coursesDelete(
    """
    filter the rows which have to be deleted
    """
    where: course_bool_exp!
  ): course_mutation_response

  """
  insert data into the table: "courses"
  """
  coursesInsert(
    """
    the rows to be inserted
    """
    objects: [course_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: course_on_conflict
  ): course_mutation_response

  """
  update data of the table: "courses"
  """
  coursesUpdate(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: course_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: course_set_input

    """
    filter the rows which have to be updated
    """
    where: course_bool_exp!
  ): course_mutation_response
  createAuth0User(arg1: Auth0Input!): Auth0Output

  """
  delete single row from the table: "pages"
  """
  pageDelete(id: Int!): page

  """
  insert a single row into the table: "pages"
  """
  pageInsert(
    """
    the row to be inserted
    """
    object: page_insert_input!

    """
    on conflict condition
    """
    on_conflict: page_on_conflict
  ): page

  """
  update single row of the table: "pages"
  """
  pageUpdate(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: page_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: page_set_input
    pk_columns: page_pk_columns_input!
  ): page

  """
  delete data from the table: "pages"
  """
  pagesDelete(
    """
    filter the rows which have to be deleted
    """
    where: page_bool_exp!
  ): page_mutation_response

  """
  insert data into the table: "pages"
  """
  pagesInsert(
    """
    the rows to be inserted
    """
    objects: [page_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: page_on_conflict
  ): page_mutation_response

  """
  update data of the table: "pages"
  """
  pagesUpdate(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: page_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: page_set_input

    """
    filter the rows which have to be updated
    """
    where: page_bool_exp!
  ): page_mutation_response

  """
  delete single row from the table: "posts"
  """
  postDelete(id: Int!): post

  """
  insert a single row into the table: "posts"
  """
  postInsert(
    """
    the row to be inserted
    """
    object: post_insert_input!

    """
    on conflict condition
    """
    on_conflict: post_on_conflict
  ): post

  """
  update single row of the table: "posts"
  """
  postUpdate(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: post_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: post_set_input
    pk_columns: post_pk_columns_input!
  ): post

  """
  delete data from the table: "posts"
  """
  postsDelete(
    """
    filter the rows which have to be deleted
    """
    where: post_bool_exp!
  ): post_mutation_response

  """
  insert data into the table: "posts"
  """
  postsInsert(
    """
    the rows to be inserted
    """
    objects: [post_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: post_on_conflict
  ): post_mutation_response

  """
  update data of the table: "posts"
  """
  postsUpdate(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: post_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: post_set_input

    """
    filter the rows which have to be updated
    """
    where: post_bool_exp!
  ): post_mutation_response

  """
  delete single row from the table: "profiles"
  """
  profileDelete(id: Int!): profile

  """
  insert a single row into the table: "profiles"
  """
  profileInsert(
    """
    the row to be inserted
    """
    object: profile_insert_input!

    """
    on conflict condition
    """
    on_conflict: profile_on_conflict
  ): profile

  """
  update single row of the table: "profiles"
  """
  profileUpdate(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: profile_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: profile_set_input
    pk_columns: profile_pk_columns_input!
  ): profile

  """
  delete data from the table: "profiles"
  """
  profilesDelete(
    """
    filter the rows which have to be deleted
    """
    where: profile_bool_exp!
  ): profile_mutation_response

  """
  insert data into the table: "profiles"
  """
  profilesInsert(
    """
    the rows to be inserted
    """
    objects: [profile_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: profile_on_conflict
  ): profile_mutation_response

  """
  update data of the table: "profiles"
  """
  profilesUpdate(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: profile_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: profile_set_input

    """
    filter the rows which have to be updated
    """
    where: profile_bool_exp!
  ): profile_mutation_response

  """
  delete single row from the table: "roles"
  """
  roleDelete(id: Int!): role

  """
  insert a single row into the table: "roles"
  """
  roleInsert(
    """
    the row to be inserted
    """
    object: role_insert_input!

    """
    on conflict condition
    """
    on_conflict: role_on_conflict
  ): role

  """
  update single row of the table: "roles"
  """
  roleUpdate(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: role_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: role_set_input
    pk_columns: role_pk_columns_input!
  ): role

  """
  delete data from the table: "roles"
  """
  rolesDelete(
    """
    filter the rows which have to be deleted
    """
    where: role_bool_exp!
  ): role_mutation_response

  """
  insert data into the table: "roles"
  """
  rolesInsert(
    """
    the rows to be inserted
    """
    objects: [role_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: role_on_conflict
  ): role_mutation_response

  """
  update data of the table: "roles"
  """
  rolesUpdate(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: role_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: role_set_input

    """
    filter the rows which have to be updated
    """
    where: role_bool_exp!
  ): role_mutation_response

  """
  delete single row from the table: "tags"
  """
  tagDelete(id: Int!): tag

  """
  insert a single row into the table: "tags"
  """
  tagInsert(
    """
    the row to be inserted
    """
    object: tag_insert_input!

    """
    on conflict condition
    """
    on_conflict: tag_on_conflict
  ): tag

  """
  update single row of the table: "tags"
  """
  tagUpdate(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: tag_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: tag_set_input
    pk_columns: tag_pk_columns_input!
  ): tag

  """
  delete data from the table: "tags"
  """
  tagsDelete(
    """
    filter the rows which have to be deleted
    """
    where: tag_bool_exp!
  ): tag_mutation_response

  """
  insert data into the table: "tags"
  """
  tagsInsert(
    """
    the rows to be inserted
    """
    objects: [tag_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: tag_on_conflict
  ): tag_mutation_response

  """
  update data of the table: "tags"
  """
  tagsUpdate(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: tag_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: tag_set_input

    """
    filter the rows which have to be updated
    """
    where: tag_bool_exp!
  ): tag_mutation_response

  """
  delete single row from the table: "topics"
  """
  topicDelete(id: Int!): topic

  """
  insert a single row into the table: "topics"
  """
  topicInsert(
    """
    the row to be inserted
    """
    object: topic_insert_input!

    """
    on conflict condition
    """
    on_conflict: topic_on_conflict
  ): topic

  """
  update single row of the table: "topics"
  """
  topicUpdate(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: topic_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: topic_set_input
    pk_columns: topic_pk_columns_input!
  ): topic

  """
  delete data from the table: "topics"
  """
  topicsDelete(
    """
    filter the rows which have to be deleted
    """
    where: topic_bool_exp!
  ): topic_mutation_response

  """
  insert data into the table: "topics"
  """
  topicsInsert(
    """
    the rows to be inserted
    """
    objects: [topic_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: topic_on_conflict
  ): topic_mutation_response

  """
  update data of the table: "topics"
  """
  topicsUpdate(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: topic_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: topic_set_input

    """
    filter the rows which have to be updated
    """
    where: topic_bool_exp!
  ): topic_mutation_response

  """
  delete single row from the table: "users"
  """
  userDelete(id: Int!): user

  """
  insert a single row into the table: "users"
  """
  userInsert(
    """
    the row to be inserted
    """
    object: user_insert_input!

    """
    on conflict condition
    """
    on_conflict: user_on_conflict
  ): user

  """
  update single row of the table: "users"
  """
  userUpdate(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: user_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: user_set_input
    pk_columns: user_pk_columns_input!
  ): user

  """
  delete data from the table: "users"
  """
  usersDelete(
    """
    filter the rows which have to be deleted
    """
    where: user_bool_exp!
  ): user_mutation_response

  """
  insert data into the table: "users"
  """
  usersInsert(
    """
    the rows to be inserted
    """
    objects: [user_insert_input!]!

    """
    on conflict condition
    """
    on_conflict: user_on_conflict
  ): user_mutation_response

  """
  update data of the table: "users"
  """
  usersUpdate(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: user_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: user_set_input

    """
    filter the rows which have to be updated
    """
    where: user_bool_exp!
  ): user_mutation_response
}

scalar numeric

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""
column ordering options
"""
enum order_by {
  """
  in ascending order, nulls last
  """
  asc

  """
  in ascending order, nulls first
  """
  asc_nulls_first

  """
  in ascending order, nulls last
  """
  asc_nulls_last

  """
  in descending order, nulls first
  """
  desc

  """
  in descending order, nulls first
  """
  desc_nulls_first

  """
  in descending order, nulls last
  """
  desc_nulls_last
}

"""
columns and relationships of "pages"
"""
type page {
  body: String!
  createdAt: timestamptz!
  createdById: Int!
  id: Int!
  slug: String!
  status: String!
  title: String!
  updatedAt: timestamptz!
  updatedById: Int!

  """
  An object relationship
  """
  user: user!

  """
  An object relationship
  """
  userByUpdatedById: user!
}

"""
aggregated selection of "pages"
"""
type page_aggregate {
  aggregate: page_aggregate_fields
  nodes: [page!]!
}

"""
aggregate fields of "pages"
"""
type page_aggregate_fields {
  avg: page_avg_fields
  count(columns: [page_select_column!], distinct: Boolean): Int!
  max: page_max_fields
  min: page_min_fields
  stddev: page_stddev_fields
  stddev_pop: page_stddev_pop_fields
  stddev_samp: page_stddev_samp_fields
  sum: page_sum_fields
  var_pop: page_var_pop_fields
  var_samp: page_var_samp_fields
  variance: page_variance_fields
}

"""
order by aggregate values of table "pages"
"""
input page_aggregate_order_by {
  avg: page_avg_order_by
  count: order_by
  max: page_max_order_by
  min: page_min_order_by
  stddev: page_stddev_order_by
  stddev_pop: page_stddev_pop_order_by
  stddev_samp: page_stddev_samp_order_by
  sum: page_sum_order_by
  var_pop: page_var_pop_order_by
  var_samp: page_var_samp_order_by
  variance: page_variance_order_by
}

"""
input type for inserting array relation for remote table "pages"
"""
input page_arr_rel_insert_input {
  data: [page_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: page_on_conflict
}

"""
aggregate avg on columns
"""
type page_avg_fields {
  createdById: Float
  id: Float
  updatedById: Float
}

"""
order by avg() on columns of table "pages"
"""
input page_avg_order_by {
  createdById: order_by
  id: order_by
  updatedById: order_by
}

"""
Boolean expression to filter rows from the table "pages". All fields are combined with a logical 'AND'.
"""
input page_bool_exp {
  _and: [page_bool_exp!]
  _not: page_bool_exp
  _or: [page_bool_exp!]
  body: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  createdById: Int_comparison_exp
  id: Int_comparison_exp
  slug: String_comparison_exp
  status: String_comparison_exp
  title: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
  updatedById: Int_comparison_exp
  user: user_bool_exp
  userByUpdatedById: user_bool_exp
}

"""
unique or primary key constraints on table "pages"
"""
enum page_constraint {
  """
  unique or primary key constraint
  """
  pages_pkey

  """
  unique or primary key constraint
  """
  pages_slug_key

  """
  unique or primary key constraint
  """
  pages_title_key
}

"""
input type for incrementing numeric columns in table "pages"
"""
input page_inc_input {
  createdById: Int
  id: Int
  updatedById: Int
}

"""
input type for inserting data into table "pages"
"""
input page_insert_input {
  body: String
  createdAt: timestamptz
  createdById: Int
  id: Int
  slug: String
  status: String
  title: String
  updatedAt: timestamptz
  updatedById: Int
  user: user_obj_rel_insert_input
  userByUpdatedById: user_obj_rel_insert_input
}

"""
aggregate max on columns
"""
type page_max_fields {
  body: String
  createdAt: timestamptz
  createdById: Int
  id: Int
  slug: String
  status: String
  title: String
  updatedAt: timestamptz
  updatedById: Int
}

"""
order by max() on columns of table "pages"
"""
input page_max_order_by {
  body: order_by
  createdAt: order_by
  createdById: order_by
  id: order_by
  slug: order_by
  status: order_by
  title: order_by
  updatedAt: order_by
  updatedById: order_by
}

"""
aggregate min on columns
"""
type page_min_fields {
  body: String
  createdAt: timestamptz
  createdById: Int
  id: Int
  slug: String
  status: String
  title: String
  updatedAt: timestamptz
  updatedById: Int
}

"""
order by min() on columns of table "pages"
"""
input page_min_order_by {
  body: order_by
  createdAt: order_by
  createdById: order_by
  id: order_by
  slug: order_by
  status: order_by
  title: order_by
  updatedAt: order_by
  updatedById: order_by
}

"""
response of any mutation on the table "pages"
"""
type page_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [page!]!
}

"""
on conflict condition type for table "pages"
"""
input page_on_conflict {
  constraint: page_constraint!
  update_columns: [page_update_column!]! = []
  where: page_bool_exp
}

"""
Ordering options when selecting data from "pages".
"""
input page_order_by {
  body: order_by
  createdAt: order_by
  createdById: order_by
  id: order_by
  slug: order_by
  status: order_by
  title: order_by
  updatedAt: order_by
  updatedById: order_by
  user: user_order_by
  userByUpdatedById: user_order_by
}

"""
primary key columns input for table: page
"""
input page_pk_columns_input {
  id: Int!
}

"""
select columns of table "pages"
"""
enum page_select_column {
  """
  column name
  """
  body

  """
  column name
  """
  createdAt

  """
  column name
  """
  createdById

  """
  column name
  """
  id

  """
  column name
  """
  slug

  """
  column name
  """
  status

  """
  column name
  """
  title

  """
  column name
  """
  updatedAt

  """
  column name
  """
  updatedById
}

"""
input type for updating data in table "pages"
"""
input page_set_input {
  body: String
  createdAt: timestamptz
  createdById: Int
  id: Int
  slug: String
  status: String
  title: String
  updatedAt: timestamptz
  updatedById: Int
}

"""
aggregate stddev on columns
"""
type page_stddev_fields {
  createdById: Float
  id: Float
  updatedById: Float
}

"""
order by stddev() on columns of table "pages"
"""
input page_stddev_order_by {
  createdById: order_by
  id: order_by
  updatedById: order_by
}

"""
aggregate stddev_pop on columns
"""
type page_stddev_pop_fields {
  createdById: Float
  id: Float
  updatedById: Float
}

"""
order by stddev_pop() on columns of table "pages"
"""
input page_stddev_pop_order_by {
  createdById: order_by
  id: order_by
  updatedById: order_by
}

"""
aggregate stddev_samp on columns
"""
type page_stddev_samp_fields {
  createdById: Float
  id: Float
  updatedById: Float
}

"""
order by stddev_samp() on columns of table "pages"
"""
input page_stddev_samp_order_by {
  createdById: order_by
  id: order_by
  updatedById: order_by
}

"""
aggregate sum on columns
"""
type page_sum_fields {
  createdById: Int
  id: Int
  updatedById: Int
}

"""
order by sum() on columns of table "pages"
"""
input page_sum_order_by {
  createdById: order_by
  id: order_by
  updatedById: order_by
}

"""
update columns of table "pages"
"""
enum page_update_column {
  """
  column name
  """
  body

  """
  column name
  """
  createdAt

  """
  column name
  """
  createdById

  """
  column name
  """
  id

  """
  column name
  """
  slug

  """
  column name
  """
  status

  """
  column name
  """
  title

  """
  column name
  """
  updatedAt

  """
  column name
  """
  updatedById
}

"""
aggregate var_pop on columns
"""
type page_var_pop_fields {
  createdById: Float
  id: Float
  updatedById: Float
}

"""
order by var_pop() on columns of table "pages"
"""
input page_var_pop_order_by {
  createdById: order_by
  id: order_by
  updatedById: order_by
}

"""
aggregate var_samp on columns
"""
type page_var_samp_fields {
  createdById: Float
  id: Float
  updatedById: Float
}

"""
order by var_samp() on columns of table "pages"
"""
input page_var_samp_order_by {
  createdById: order_by
  id: order_by
  updatedById: order_by
}

"""
aggregate variance on columns
"""
type page_variance_fields {
  createdById: Float
  id: Float
  updatedById: Float
}

"""
order by variance() on columns of table "pages"
"""
input page_variance_order_by {
  createdById: order_by
  id: order_by
  updatedById: order_by
}

"""
columns and relationships of "posts"
"""
type post {
  content: String!
  createdAt: timestamptz!
  createdById: Int!
  id: Int!
  slug: String!
  status: String!
  summary: String!
  tagIds(
    """
    JSON select path
    """
    path: String
  ): json!
  title: String!
  topicIds(
    """
    JSON select path
    """
    path: String
  ): json!
  updatedAt: timestamptz!
  updatedById: Int!

  """
  An object relationship
  """
  userByCreatedById: user!

  """
  An object relationship
  """
  userByUpdatedById: user!
}

"""
aggregated selection of "posts"
"""
type post_aggregate {
  aggregate: post_aggregate_fields
  nodes: [post!]!
}

"""
aggregate fields of "posts"
"""
type post_aggregate_fields {
  avg: post_avg_fields
  count(columns: [post_select_column!], distinct: Boolean): Int!
  max: post_max_fields
  min: post_min_fields
  stddev: post_stddev_fields
  stddev_pop: post_stddev_pop_fields
  stddev_samp: post_stddev_samp_fields
  sum: post_sum_fields
  var_pop: post_var_pop_fields
  var_samp: post_var_samp_fields
  variance: post_variance_fields
}

"""
order by aggregate values of table "posts"
"""
input post_aggregate_order_by {
  avg: post_avg_order_by
  count: order_by
  max: post_max_order_by
  min: post_min_order_by
  stddev: post_stddev_order_by
  stddev_pop: post_stddev_pop_order_by
  stddev_samp: post_stddev_samp_order_by
  sum: post_sum_order_by
  var_pop: post_var_pop_order_by
  var_samp: post_var_samp_order_by
  variance: post_variance_order_by
}

"""
input type for inserting array relation for remote table "posts"
"""
input post_arr_rel_insert_input {
  data: [post_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: post_on_conflict
}

"""
aggregate avg on columns
"""
type post_avg_fields {
  createdById: Float
  id: Float
  updatedById: Float
}

"""
order by avg() on columns of table "posts"
"""
input post_avg_order_by {
  createdById: order_by
  id: order_by
  updatedById: order_by
}

"""
Boolean expression to filter rows from the table "posts". All fields are combined with a logical 'AND'.
"""
input post_bool_exp {
  _and: [post_bool_exp!]
  _not: post_bool_exp
  _or: [post_bool_exp!]
  content: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  createdById: Int_comparison_exp
  id: Int_comparison_exp
  slug: String_comparison_exp
  status: String_comparison_exp
  summary: String_comparison_exp
  tagIds: json_comparison_exp
  title: String_comparison_exp
  topicIds: json_comparison_exp
  updatedAt: timestamptz_comparison_exp
  updatedById: Int_comparison_exp
  userByCreatedById: user_bool_exp
  userByUpdatedById: user_bool_exp
}

"""
unique or primary key constraints on table "posts"
"""
enum post_constraint {
  """
  unique or primary key constraint
  """
  posts_pkey

  """
  unique or primary key constraint
  """
  posts_slug_key

  """
  unique or primary key constraint
  """
  posts_title_key
}

"""
input type for incrementing numeric columns in table "posts"
"""
input post_inc_input {
  createdById: Int
  id: Int
  updatedById: Int
}

"""
input type for inserting data into table "posts"
"""
input post_insert_input {
  content: String
  createdAt: timestamptz
  createdById: Int
  id: Int
  slug: String
  status: String
  summary: String
  tagIds: json
  title: String
  topicIds: json
  updatedAt: timestamptz
  updatedById: Int
  userByCreatedById: user_obj_rel_insert_input
  userByUpdatedById: user_obj_rel_insert_input
}

"""
aggregate max on columns
"""
type post_max_fields {
  content: String
  createdAt: timestamptz
  createdById: Int
  id: Int
  slug: String
  status: String
  summary: String
  title: String
  updatedAt: timestamptz
  updatedById: Int
}

"""
order by max() on columns of table "posts"
"""
input post_max_order_by {
  content: order_by
  createdAt: order_by
  createdById: order_by
  id: order_by
  slug: order_by
  status: order_by
  summary: order_by
  title: order_by
  updatedAt: order_by
  updatedById: order_by
}

"""
aggregate min on columns
"""
type post_min_fields {
  content: String
  createdAt: timestamptz
  createdById: Int
  id: Int
  slug: String
  status: String
  summary: String
  title: String
  updatedAt: timestamptz
  updatedById: Int
}

"""
order by min() on columns of table "posts"
"""
input post_min_order_by {
  content: order_by
  createdAt: order_by
  createdById: order_by
  id: order_by
  slug: order_by
  status: order_by
  summary: order_by
  title: order_by
  updatedAt: order_by
  updatedById: order_by
}

"""
response of any mutation on the table "posts"
"""
type post_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [post!]!
}

"""
on conflict condition type for table "posts"
"""
input post_on_conflict {
  constraint: post_constraint!
  update_columns: [post_update_column!]! = []
  where: post_bool_exp
}

"""
Ordering options when selecting data from "posts".
"""
input post_order_by {
  content: order_by
  createdAt: order_by
  createdById: order_by
  id: order_by
  slug: order_by
  status: order_by
  summary: order_by
  tagIds: order_by
  title: order_by
  topicIds: order_by
  updatedAt: order_by
  updatedById: order_by
  userByCreatedById: user_order_by
  userByUpdatedById: user_order_by
}

"""
primary key columns input for table: post
"""
input post_pk_columns_input {
  id: Int!
}

"""
select columns of table "posts"
"""
enum post_select_column {
  """
  column name
  """
  content

  """
  column name
  """
  createdAt

  """
  column name
  """
  createdById

  """
  column name
  """
  id

  """
  column name
  """
  slug

  """
  column name
  """
  status

  """
  column name
  """
  summary

  """
  column name
  """
  tagIds

  """
  column name
  """
  title

  """
  column name
  """
  topicIds

  """
  column name
  """
  updatedAt

  """
  column name
  """
  updatedById
}

"""
input type for updating data in table "posts"
"""
input post_set_input {
  content: String
  createdAt: timestamptz
  createdById: Int
  id: Int
  slug: String
  status: String
  summary: String
  tagIds: json
  title: String
  topicIds: json
  updatedAt: timestamptz
  updatedById: Int
}

"""
aggregate stddev on columns
"""
type post_stddev_fields {
  createdById: Float
  id: Float
  updatedById: Float
}

"""
order by stddev() on columns of table "posts"
"""
input post_stddev_order_by {
  createdById: order_by
  id: order_by
  updatedById: order_by
}

"""
aggregate stddev_pop on columns
"""
type post_stddev_pop_fields {
  createdById: Float
  id: Float
  updatedById: Float
}

"""
order by stddev_pop() on columns of table "posts"
"""
input post_stddev_pop_order_by {
  createdById: order_by
  id: order_by
  updatedById: order_by
}

"""
aggregate stddev_samp on columns
"""
type post_stddev_samp_fields {
  createdById: Float
  id: Float
  updatedById: Float
}

"""
order by stddev_samp() on columns of table "posts"
"""
input post_stddev_samp_order_by {
  createdById: order_by
  id: order_by
  updatedById: order_by
}

"""
aggregate sum on columns
"""
type post_sum_fields {
  createdById: Int
  id: Int
  updatedById: Int
}

"""
order by sum() on columns of table "posts"
"""
input post_sum_order_by {
  createdById: order_by
  id: order_by
  updatedById: order_by
}

"""
update columns of table "posts"
"""
enum post_update_column {
  """
  column name
  """
  content

  """
  column name
  """
  createdAt

  """
  column name
  """
  createdById

  """
  column name
  """
  id

  """
  column name
  """
  slug

  """
  column name
  """
  status

  """
  column name
  """
  summary

  """
  column name
  """
  tagIds

  """
  column name
  """
  title

  """
  column name
  """
  topicIds

  """
  column name
  """
  updatedAt

  """
  column name
  """
  updatedById
}

"""
aggregate var_pop on columns
"""
type post_var_pop_fields {
  createdById: Float
  id: Float
  updatedById: Float
}

"""
order by var_pop() on columns of table "posts"
"""
input post_var_pop_order_by {
  createdById: order_by
  id: order_by
  updatedById: order_by
}

"""
aggregate var_samp on columns
"""
type post_var_samp_fields {
  createdById: Float
  id: Float
  updatedById: Float
}

"""
order by var_samp() on columns of table "posts"
"""
input post_var_samp_order_by {
  createdById: order_by
  id: order_by
  updatedById: order_by
}

"""
aggregate variance on columns
"""
type post_variance_fields {
  createdById: Float
  id: Float
  updatedById: Float
}

"""
order by variance() on columns of table "posts"
"""
input post_variance_order_by {
  createdById: order_by
  id: order_by
  updatedById: order_by
}

"""
columns and relationships of "profiles"
"""
type profile {
  avatarUrl: String
  biography: String
  id: Int!
  isPublic: Boolean!
  links(
    """
    JSON select path
    """
    path: String
  ): json
  location: String
  phoneNumber: String
  phoneVerified: Boolean
  slug: String!

  """
  An object relationship
  """
  user: user!
  userId: Int!
}

"""
aggregated selection of "profiles"
"""
type profile_aggregate {
  aggregate: profile_aggregate_fields
  nodes: [profile!]!
}

"""
aggregate fields of "profiles"
"""
type profile_aggregate_fields {
  avg: profile_avg_fields
  count(columns: [profile_select_column!], distinct: Boolean): Int!
  max: profile_max_fields
  min: profile_min_fields
  stddev: profile_stddev_fields
  stddev_pop: profile_stddev_pop_fields
  stddev_samp: profile_stddev_samp_fields
  sum: profile_sum_fields
  var_pop: profile_var_pop_fields
  var_samp: profile_var_samp_fields
  variance: profile_variance_fields
}

"""
aggregate avg on columns
"""
type profile_avg_fields {
  id: Float
  userId: Float
}

"""
Boolean expression to filter rows from the table "profiles". All fields are combined with a logical 'AND'.
"""
input profile_bool_exp {
  _and: [profile_bool_exp!]
  _not: profile_bool_exp
  _or: [profile_bool_exp!]
  avatarUrl: String_comparison_exp
  biography: String_comparison_exp
  id: Int_comparison_exp
  isPublic: Boolean_comparison_exp
  links: json_comparison_exp
  location: String_comparison_exp
  phoneNumber: String_comparison_exp
  phoneVerified: Boolean_comparison_exp
  slug: String_comparison_exp
  user: user_bool_exp
  userId: Int_comparison_exp
}

"""
unique or primary key constraints on table "profiles"
"""
enum profile_constraint {
  """
  unique or primary key constraint
  """
  user_meta_pkey

  """
  unique or primary key constraint
  """
  user_meta_user_Id_key

  """
  unique or primary key constraint
  """
  user_profiles_phone_number_key

  """
  unique or primary key constraint
  """
  user_profiles_slug_key
}

"""
input type for incrementing numeric columns in table "profiles"
"""
input profile_inc_input {
  id: Int
  userId: Int
}

"""
input type for inserting data into table "profiles"
"""
input profile_insert_input {
  avatarUrl: String
  biography: String
  id: Int
  isPublic: Boolean
  links: json
  location: String
  phoneNumber: String
  phoneVerified: Boolean
  slug: String
  user: user_obj_rel_insert_input
  userId: Int
}

"""
aggregate max on columns
"""
type profile_max_fields {
  avatarUrl: String
  biography: String
  id: Int
  location: String
  phoneNumber: String
  slug: String
  userId: Int
}

"""
aggregate min on columns
"""
type profile_min_fields {
  avatarUrl: String
  biography: String
  id: Int
  location: String
  phoneNumber: String
  slug: String
  userId: Int
}

"""
response of any mutation on the table "profiles"
"""
type profile_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [profile!]!
}

"""
input type for inserting object relation for remote table "profiles"
"""
input profile_obj_rel_insert_input {
  data: profile_insert_input!

  """
  on conflict condition
  """
  on_conflict: profile_on_conflict
}

"""
on conflict condition type for table "profiles"
"""
input profile_on_conflict {
  constraint: profile_constraint!
  update_columns: [profile_update_column!]! = []
  where: profile_bool_exp
}

"""
Ordering options when selecting data from "profiles".
"""
input profile_order_by {
  avatarUrl: order_by
  biography: order_by
  id: order_by
  isPublic: order_by
  links: order_by
  location: order_by
  phoneNumber: order_by
  phoneVerified: order_by
  slug: order_by
  user: user_order_by
  userId: order_by
}

"""
primary key columns input for table: profile
"""
input profile_pk_columns_input {
  id: Int!
}

"""
select columns of table "profiles"
"""
enum profile_select_column {
  """
  column name
  """
  avatarUrl

  """
  column name
  """
  biography

  """
  column name
  """
  id

  """
  column name
  """
  isPublic

  """
  column name
  """
  links

  """
  column name
  """
  location

  """
  column name
  """
  phoneNumber

  """
  column name
  """
  phoneVerified

  """
  column name
  """
  slug

  """
  column name
  """
  userId
}

"""
input type for updating data in table "profiles"
"""
input profile_set_input {
  avatarUrl: String
  biography: String
  id: Int
  isPublic: Boolean
  links: json
  location: String
  phoneNumber: String
  phoneVerified: Boolean
  slug: String
  userId: Int
}

"""
aggregate stddev on columns
"""
type profile_stddev_fields {
  id: Float
  userId: Float
}

"""
aggregate stddev_pop on columns
"""
type profile_stddev_pop_fields {
  id: Float
  userId: Float
}

"""
aggregate stddev_samp on columns
"""
type profile_stddev_samp_fields {
  id: Float
  userId: Float
}

"""
aggregate sum on columns
"""
type profile_sum_fields {
  id: Int
  userId: Int
}

"""
update columns of table "profiles"
"""
enum profile_update_column {
  """
  column name
  """
  avatarUrl

  """
  column name
  """
  biography

  """
  column name
  """
  id

  """
  column name
  """
  isPublic

  """
  column name
  """
  links

  """
  column name
  """
  location

  """
  column name
  """
  phoneNumber

  """
  column name
  """
  phoneVerified

  """
  column name
  """
  slug

  """
  column name
  """
  userId
}

"""
aggregate var_pop on columns
"""
type profile_var_pop_fields {
  id: Float
  userId: Float
}

"""
aggregate var_samp on columns
"""
type profile_var_samp_fields {
  id: Float
  userId: Float
}

"""
aggregate variance on columns
"""
type profile_variance_fields {
  id: Float
  userId: Float
}

type query_root {
  """
  fetch data from the table: "activity_logins" using primary key columns
  """
  activityLogin(id: Int!): activityLogin

  """
  fetch data from the table: "activity_logins"
  """
  activityLogins(
    """
    distinct select on columns
    """
    distinct_on: [activityLogin_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [activityLogin_order_by!]

    """
    filter the rows returned
    """
    where: activityLogin_bool_exp
  ): [activityLogin!]!

  """
  fetch aggregated fields from the table: "activity_logins"
  """
  activityLoginsAggregate(
    """
    distinct select on columns
    """
    distinct_on: [activityLogin_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [activityLogin_order_by!]

    """
    filter the rows returned
    """
    where: activityLogin_bool_exp
  ): activityLogin_aggregate!

  """
  fetch data from the table: "courses" using primary key columns
  """
  course(id: Int!): course

  """
  An array relationship
  """
  courses(
    """
    distinct select on columns
    """
    distinct_on: [course_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [course_order_by!]

    """
    filter the rows returned
    """
    where: course_bool_exp
  ): [course!]!

  """
  fetch aggregated fields from the table: "courses"
  """
  coursesAggregate(
    """
    distinct select on columns
    """
    distinct_on: [course_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [course_order_by!]

    """
    filter the rows returned
    """
    where: course_bool_exp
  ): course_aggregate!

  """
  fetch data from the table: "pages" using primary key columns
  """
  page(id: Int!): page

  """
  An array relationship
  """
  pages(
    """
    distinct select on columns
    """
    distinct_on: [page_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_order_by!]

    """
    filter the rows returned
    """
    where: page_bool_exp
  ): [page!]!

  """
  fetch aggregated fields from the table: "pages"
  """
  pagesAggregate(
    """
    distinct select on columns
    """
    distinct_on: [page_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_order_by!]

    """
    filter the rows returned
    """
    where: page_bool_exp
  ): page_aggregate!

  """
  fetch data from the table: "posts" using primary key columns
  """
  post(id: Int!): post

  """
  An array relationship
  """
  posts(
    """
    distinct select on columns
    """
    distinct_on: [post_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [post_order_by!]

    """
    filter the rows returned
    """
    where: post_bool_exp
  ): [post!]!

  """
  fetch aggregated fields from the table: "posts"
  """
  postsAggregate(
    """
    distinct select on columns
    """
    distinct_on: [post_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [post_order_by!]

    """
    filter the rows returned
    """
    where: post_bool_exp
  ): post_aggregate!

  """
  fetch data from the table: "profiles" using primary key columns
  """
  profile(id: Int!): profile

  """
  fetch data from the table: "profiles"
  """
  profiles(
    """
    distinct select on columns
    """
    distinct_on: [profile_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [profile_order_by!]

    """
    filter the rows returned
    """
    where: profile_bool_exp
  ): [profile!]!

  """
  fetch aggregated fields from the table: "profiles"
  """
  profilesAggregate(
    """
    distinct select on columns
    """
    distinct_on: [profile_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [profile_order_by!]

    """
    filter the rows returned
    """
    where: profile_bool_exp
  ): profile_aggregate!

  """
  fetch data from the table: "roles" using primary key columns
  """
  role(id: Int!): role

  """
  fetch data from the table: "roles"
  """
  roles(
    """
    distinct select on columns
    """
    distinct_on: [role_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [role_order_by!]

    """
    filter the rows returned
    """
    where: role_bool_exp
  ): [role!]!

  """
  fetch aggregated fields from the table: "roles"
  """
  rolesAggregate(
    """
    distinct select on columns
    """
    distinct_on: [role_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [role_order_by!]

    """
    filter the rows returned
    """
    where: role_bool_exp
  ): role_aggregate!

  """
  fetch data from the table: "tags" using primary key columns
  """
  tag(id: Int!): tag

  """
  fetch data from the table: "tags"
  """
  tags(
    """
    distinct select on columns
    """
    distinct_on: [tag_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_order_by!]

    """
    filter the rows returned
    """
    where: tag_bool_exp
  ): [tag!]!

  """
  fetch aggregated fields from the table: "tags"
  """
  tagsAggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_order_by!]

    """
    filter the rows returned
    """
    where: tag_bool_exp
  ): tag_aggregate!

  """
  fetch data from the table: "topics" using primary key columns
  """
  topic(id: Int!): topic

  """
  An array relationship
  """
  topics(
    """
    distinct select on columns
    """
    distinct_on: [topic_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [topic_order_by!]

    """
    filter the rows returned
    """
    where: topic_bool_exp
  ): [topic!]!

  """
  fetch aggregated fields from the table: "topics"
  """
  topicsAggregate(
    """
    distinct select on columns
    """
    distinct_on: [topic_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [topic_order_by!]

    """
    filter the rows returned
    """
    where: topic_bool_exp
  ): topic_aggregate!

  """
  fetch data from the table: "users" using primary key columns
  """
  user(id: Int!): user

  """
  An array relationship
  """
  users(
    """
    distinct select on columns
    """
    distinct_on: [user_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [user_order_by!]

    """
    filter the rows returned
    """
    where: user_bool_exp
  ): [user!]!

  """
  fetch aggregated fields from the table: "users"
  """
  usersAggregate(
    """
    distinct select on columns
    """
    distinct_on: [user_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [user_order_by!]

    """
    filter the rows returned
    """
    where: user_bool_exp
  ): user_aggregate!
}

"""
columns and relationships of "roles"
"""
type role {
  description: String
  id: Int!
  name: String
  type: String

  """
  An array relationship
  """
  users(
    """
    distinct select on columns
    """
    distinct_on: [user_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [user_order_by!]

    """
    filter the rows returned
    """
    where: user_bool_exp
  ): [user!]!

  """
  An aggregate relationship
  """
  users_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [user_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [user_order_by!]

    """
    filter the rows returned
    """
    where: user_bool_exp
  ): user_aggregate!
}

"""
aggregated selection of "roles"
"""
type role_aggregate {
  aggregate: role_aggregate_fields
  nodes: [role!]!
}

"""
aggregate fields of "roles"
"""
type role_aggregate_fields {
  avg: role_avg_fields
  count(columns: [role_select_column!], distinct: Boolean): Int!
  max: role_max_fields
  min: role_min_fields
  stddev: role_stddev_fields
  stddev_pop: role_stddev_pop_fields
  stddev_samp: role_stddev_samp_fields
  sum: role_sum_fields
  var_pop: role_var_pop_fields
  var_samp: role_var_samp_fields
  variance: role_variance_fields
}

"""
aggregate avg on columns
"""
type role_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "roles". All fields are combined with a logical 'AND'.
"""
input role_bool_exp {
  _and: [role_bool_exp!]
  _not: role_bool_exp
  _or: [role_bool_exp!]
  description: String_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  type: String_comparison_exp
  users: user_bool_exp
}

"""
unique or primary key constraints on table "roles"
"""
enum role_constraint {
  """
  unique or primary key constraint
  """
  roles_name_key

  """
  unique or primary key constraint
  """
  roles_shortname_key

  """
  unique or primary key constraint
  """
  user_types_pkey
}

"""
input type for incrementing numeric columns in table "roles"
"""
input role_inc_input {
  id: Int
}

"""
input type for inserting data into table "roles"
"""
input role_insert_input {
  description: String
  id: Int
  name: String
  type: String
  users: user_arr_rel_insert_input
}

"""
aggregate max on columns
"""
type role_max_fields {
  description: String
  id: Int
  name: String
  type: String
}

"""
aggregate min on columns
"""
type role_min_fields {
  description: String
  id: Int
  name: String
  type: String
}

"""
response of any mutation on the table "roles"
"""
type role_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [role!]!
}

"""
input type for inserting object relation for remote table "roles"
"""
input role_obj_rel_insert_input {
  data: role_insert_input!

  """
  on conflict condition
  """
  on_conflict: role_on_conflict
}

"""
on conflict condition type for table "roles"
"""
input role_on_conflict {
  constraint: role_constraint!
  update_columns: [role_update_column!]! = []
  where: role_bool_exp
}

"""
Ordering options when selecting data from "roles".
"""
input role_order_by {
  description: order_by
  id: order_by
  name: order_by
  type: order_by
  users_aggregate: user_aggregate_order_by
}

"""
primary key columns input for table: role
"""
input role_pk_columns_input {
  id: Int!
}

"""
select columns of table "roles"
"""
enum role_select_column {
  """
  column name
  """
  description

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  type
}

"""
input type for updating data in table "roles"
"""
input role_set_input {
  description: String
  id: Int
  name: String
  type: String
}

"""
aggregate stddev on columns
"""
type role_stddev_fields {
  id: Float
}

"""
aggregate stddev_pop on columns
"""
type role_stddev_pop_fields {
  id: Float
}

"""
aggregate stddev_samp on columns
"""
type role_stddev_samp_fields {
  id: Float
}

"""
aggregate sum on columns
"""
type role_sum_fields {
  id: Int
}

"""
update columns of table "roles"
"""
enum role_update_column {
  """
  column name
  """
  description

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  type
}

"""
aggregate var_pop on columns
"""
type role_var_pop_fields {
  id: Float
}

"""
aggregate var_samp on columns
"""
type role_var_samp_fields {
  id: Float
}

"""
aggregate variance on columns
"""
type role_variance_fields {
  id: Float
}

type subscription_root {
  """
  fetch data from the table: "activity_logins" using primary key columns
  """
  activityLogin(id: Int!): activityLogin

  """
  fetch data from the table: "activity_logins"
  """
  activityLogins(
    """
    distinct select on columns
    """
    distinct_on: [activityLogin_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [activityLogin_order_by!]

    """
    filter the rows returned
    """
    where: activityLogin_bool_exp
  ): [activityLogin!]!

  """
  fetch aggregated fields from the table: "activity_logins"
  """
  activityLoginsAggregate(
    """
    distinct select on columns
    """
    distinct_on: [activityLogin_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [activityLogin_order_by!]

    """
    filter the rows returned
    """
    where: activityLogin_bool_exp
  ): activityLogin_aggregate!

  """
  fetch data from the table: "courses" using primary key columns
  """
  course(id: Int!): course

  """
  An array relationship
  """
  courses(
    """
    distinct select on columns
    """
    distinct_on: [course_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [course_order_by!]

    """
    filter the rows returned
    """
    where: course_bool_exp
  ): [course!]!

  """
  fetch aggregated fields from the table: "courses"
  """
  coursesAggregate(
    """
    distinct select on columns
    """
    distinct_on: [course_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [course_order_by!]

    """
    filter the rows returned
    """
    where: course_bool_exp
  ): course_aggregate!

  """
  fetch data from the table: "pages" using primary key columns
  """
  page(id: Int!): page

  """
  An array relationship
  """
  pages(
    """
    distinct select on columns
    """
    distinct_on: [page_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_order_by!]

    """
    filter the rows returned
    """
    where: page_bool_exp
  ): [page!]!

  """
  fetch aggregated fields from the table: "pages"
  """
  pagesAggregate(
    """
    distinct select on columns
    """
    distinct_on: [page_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_order_by!]

    """
    filter the rows returned
    """
    where: page_bool_exp
  ): page_aggregate!

  """
  fetch data from the table: "posts" using primary key columns
  """
  post(id: Int!): post

  """
  An array relationship
  """
  posts(
    """
    distinct select on columns
    """
    distinct_on: [post_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [post_order_by!]

    """
    filter the rows returned
    """
    where: post_bool_exp
  ): [post!]!

  """
  fetch aggregated fields from the table: "posts"
  """
  postsAggregate(
    """
    distinct select on columns
    """
    distinct_on: [post_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [post_order_by!]

    """
    filter the rows returned
    """
    where: post_bool_exp
  ): post_aggregate!

  """
  fetch data from the table: "profiles" using primary key columns
  """
  profile(id: Int!): profile

  """
  fetch data from the table: "profiles"
  """
  profiles(
    """
    distinct select on columns
    """
    distinct_on: [profile_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [profile_order_by!]

    """
    filter the rows returned
    """
    where: profile_bool_exp
  ): [profile!]!

  """
  fetch aggregated fields from the table: "profiles"
  """
  profilesAggregate(
    """
    distinct select on columns
    """
    distinct_on: [profile_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [profile_order_by!]

    """
    filter the rows returned
    """
    where: profile_bool_exp
  ): profile_aggregate!

  """
  fetch data from the table: "roles" using primary key columns
  """
  role(id: Int!): role

  """
  fetch data from the table: "roles"
  """
  roles(
    """
    distinct select on columns
    """
    distinct_on: [role_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [role_order_by!]

    """
    filter the rows returned
    """
    where: role_bool_exp
  ): [role!]!

  """
  fetch aggregated fields from the table: "roles"
  """
  rolesAggregate(
    """
    distinct select on columns
    """
    distinct_on: [role_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [role_order_by!]

    """
    filter the rows returned
    """
    where: role_bool_exp
  ): role_aggregate!

  """
  fetch data from the table: "tags" using primary key columns
  """
  tag(id: Int!): tag

  """
  fetch data from the table: "tags"
  """
  tags(
    """
    distinct select on columns
    """
    distinct_on: [tag_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_order_by!]

    """
    filter the rows returned
    """
    where: tag_bool_exp
  ): [tag!]!

  """
  fetch aggregated fields from the table: "tags"
  """
  tagsAggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_order_by!]

    """
    filter the rows returned
    """
    where: tag_bool_exp
  ): tag_aggregate!

  """
  fetch data from the table: "topics" using primary key columns
  """
  topic(id: Int!): topic

  """
  An array relationship
  """
  topics(
    """
    distinct select on columns
    """
    distinct_on: [topic_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [topic_order_by!]

    """
    filter the rows returned
    """
    where: topic_bool_exp
  ): [topic!]!

  """
  fetch aggregated fields from the table: "topics"
  """
  topicsAggregate(
    """
    distinct select on columns
    """
    distinct_on: [topic_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [topic_order_by!]

    """
    filter the rows returned
    """
    where: topic_bool_exp
  ): topic_aggregate!

  """
  fetch data from the table: "users" using primary key columns
  """
  user(id: Int!): user

  """
  An array relationship
  """
  users(
    """
    distinct select on columns
    """
    distinct_on: [user_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [user_order_by!]

    """
    filter the rows returned
    """
    where: user_bool_exp
  ): [user!]!

  """
  fetch aggregated fields from the table: "users"
  """
  usersAggregate(
    """
    distinct select on columns
    """
    distinct_on: [user_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [user_order_by!]

    """
    filter the rows returned
    """
    where: user_bool_exp
  ): user_aggregate!
}

"""
columns and relationships of "tags"
"""
type tag {
  createdAt: timestamptz!
  createdById: Int!
  id: Int!
  slug: String!
  title: String!
  updatedAt: timestamptz!
  updatedById: Int!

  """
  An object relationship
  """
  user: user!

  """
  An object relationship
  """
  userByUpdatedById: user!
}

"""
aggregated selection of "tags"
"""
type tag_aggregate {
  aggregate: tag_aggregate_fields
  nodes: [tag!]!
}

"""
aggregate fields of "tags"
"""
type tag_aggregate_fields {
  avg: tag_avg_fields
  count(columns: [tag_select_column!], distinct: Boolean): Int!
  max: tag_max_fields
  min: tag_min_fields
  stddev: tag_stddev_fields
  stddev_pop: tag_stddev_pop_fields
  stddev_samp: tag_stddev_samp_fields
  sum: tag_sum_fields
  var_pop: tag_var_pop_fields
  var_samp: tag_var_samp_fields
  variance: tag_variance_fields
}

"""
order by aggregate values of table "tags"
"""
input tag_aggregate_order_by {
  avg: tag_avg_order_by
  count: order_by
  max: tag_max_order_by
  min: tag_min_order_by
  stddev: tag_stddev_order_by
  stddev_pop: tag_stddev_pop_order_by
  stddev_samp: tag_stddev_samp_order_by
  sum: tag_sum_order_by
  var_pop: tag_var_pop_order_by
  var_samp: tag_var_samp_order_by
  variance: tag_variance_order_by
}

"""
input type for inserting array relation for remote table "tags"
"""
input tag_arr_rel_insert_input {
  data: [tag_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: tag_on_conflict
}

"""
aggregate avg on columns
"""
type tag_avg_fields {
  createdById: Float
  id: Float
  updatedById: Float
}

"""
order by avg() on columns of table "tags"
"""
input tag_avg_order_by {
  createdById: order_by
  id: order_by
  updatedById: order_by
}

"""
Boolean expression to filter rows from the table "tags". All fields are combined with a logical 'AND'.
"""
input tag_bool_exp {
  _and: [tag_bool_exp!]
  _not: tag_bool_exp
  _or: [tag_bool_exp!]
  createdAt: timestamptz_comparison_exp
  createdById: Int_comparison_exp
  id: Int_comparison_exp
  slug: String_comparison_exp
  title: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
  updatedById: Int_comparison_exp
  user: user_bool_exp
  userByUpdatedById: user_bool_exp
}

"""
unique or primary key constraints on table "tags"
"""
enum tag_constraint {
  """
  unique or primary key constraint
  """
  tags_pkey

  """
  unique or primary key constraint
  """
  tags_slug_key

  """
  unique or primary key constraint
  """
  tags_title_key
}

"""
input type for incrementing numeric columns in table "tags"
"""
input tag_inc_input {
  createdById: Int
  id: Int
  updatedById: Int
}

"""
input type for inserting data into table "tags"
"""
input tag_insert_input {
  createdAt: timestamptz
  createdById: Int
  id: Int
  slug: String
  title: String
  updatedAt: timestamptz
  updatedById: Int
  user: user_obj_rel_insert_input
  userByUpdatedById: user_obj_rel_insert_input
}

"""
aggregate max on columns
"""
type tag_max_fields {
  createdAt: timestamptz
  createdById: Int
  id: Int
  slug: String
  title: String
  updatedAt: timestamptz
  updatedById: Int
}

"""
order by max() on columns of table "tags"
"""
input tag_max_order_by {
  createdAt: order_by
  createdById: order_by
  id: order_by
  slug: order_by
  title: order_by
  updatedAt: order_by
  updatedById: order_by
}

"""
aggregate min on columns
"""
type tag_min_fields {
  createdAt: timestamptz
  createdById: Int
  id: Int
  slug: String
  title: String
  updatedAt: timestamptz
  updatedById: Int
}

"""
order by min() on columns of table "tags"
"""
input tag_min_order_by {
  createdAt: order_by
  createdById: order_by
  id: order_by
  slug: order_by
  title: order_by
  updatedAt: order_by
  updatedById: order_by
}

"""
response of any mutation on the table "tags"
"""
type tag_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [tag!]!
}

"""
on conflict condition type for table "tags"
"""
input tag_on_conflict {
  constraint: tag_constraint!
  update_columns: [tag_update_column!]! = []
  where: tag_bool_exp
}

"""
Ordering options when selecting data from "tags".
"""
input tag_order_by {
  createdAt: order_by
  createdById: order_by
  id: order_by
  slug: order_by
  title: order_by
  updatedAt: order_by
  updatedById: order_by
  user: user_order_by
  userByUpdatedById: user_order_by
}

"""
primary key columns input for table: tag
"""
input tag_pk_columns_input {
  id: Int!
}

"""
select columns of table "tags"
"""
enum tag_select_column {
  """
  column name
  """
  createdAt

  """
  column name
  """
  createdById

  """
  column name
  """
  id

  """
  column name
  """
  slug

  """
  column name
  """
  title

  """
  column name
  """
  updatedAt

  """
  column name
  """
  updatedById
}

"""
input type for updating data in table "tags"
"""
input tag_set_input {
  createdAt: timestamptz
  createdById: Int
  id: Int
  slug: String
  title: String
  updatedAt: timestamptz
  updatedById: Int
}

"""
aggregate stddev on columns
"""
type tag_stddev_fields {
  createdById: Float
  id: Float
  updatedById: Float
}

"""
order by stddev() on columns of table "tags"
"""
input tag_stddev_order_by {
  createdById: order_by
  id: order_by
  updatedById: order_by
}

"""
aggregate stddev_pop on columns
"""
type tag_stddev_pop_fields {
  createdById: Float
  id: Float
  updatedById: Float
}

"""
order by stddev_pop() on columns of table "tags"
"""
input tag_stddev_pop_order_by {
  createdById: order_by
  id: order_by
  updatedById: order_by
}

"""
aggregate stddev_samp on columns
"""
type tag_stddev_samp_fields {
  createdById: Float
  id: Float
  updatedById: Float
}

"""
order by stddev_samp() on columns of table "tags"
"""
input tag_stddev_samp_order_by {
  createdById: order_by
  id: order_by
  updatedById: order_by
}

"""
aggregate sum on columns
"""
type tag_sum_fields {
  createdById: Int
  id: Int
  updatedById: Int
}

"""
order by sum() on columns of table "tags"
"""
input tag_sum_order_by {
  createdById: order_by
  id: order_by
  updatedById: order_by
}

"""
update columns of table "tags"
"""
enum tag_update_column {
  """
  column name
  """
  createdAt

  """
  column name
  """
  createdById

  """
  column name
  """
  id

  """
  column name
  """
  slug

  """
  column name
  """
  title

  """
  column name
  """
  updatedAt

  """
  column name
  """
  updatedById
}

"""
aggregate var_pop on columns
"""
type tag_var_pop_fields {
  createdById: Float
  id: Float
  updatedById: Float
}

"""
order by var_pop() on columns of table "tags"
"""
input tag_var_pop_order_by {
  createdById: order_by
  id: order_by
  updatedById: order_by
}

"""
aggregate var_samp on columns
"""
type tag_var_samp_fields {
  createdById: Float
  id: Float
  updatedById: Float
}

"""
order by var_samp() on columns of table "tags"
"""
input tag_var_samp_order_by {
  createdById: order_by
  id: order_by
  updatedById: order_by
}

"""
aggregate variance on columns
"""
type tag_variance_fields {
  createdById: Float
  id: Float
  updatedById: Float
}

"""
order by variance() on columns of table "tags"
"""
input tag_variance_order_by {
  createdById: order_by
  id: order_by
  updatedById: order_by
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "topics"
"""
type topic {
  createdAt: timestamptz!
  createdById: Int!
  id: Int!
  parentTopicIds(
    """
    JSON select path
    """
    path: String
  ): json
  slug: String!
  title: String!
  updatedAt: timestamptz!
  updatedById: Int!

  """
  An object relationship
  """
  user: user!

  """
  An object relationship
  """
  userByUpdatedById: user!
}

"""
aggregated selection of "topics"
"""
type topic_aggregate {
  aggregate: topic_aggregate_fields
  nodes: [topic!]!
}

"""
aggregate fields of "topics"
"""
type topic_aggregate_fields {
  avg: topic_avg_fields
  count(columns: [topic_select_column!], distinct: Boolean): Int!
  max: topic_max_fields
  min: topic_min_fields
  stddev: topic_stddev_fields
  stddev_pop: topic_stddev_pop_fields
  stddev_samp: topic_stddev_samp_fields
  sum: topic_sum_fields
  var_pop: topic_var_pop_fields
  var_samp: topic_var_samp_fields
  variance: topic_variance_fields
}

"""
order by aggregate values of table "topics"
"""
input topic_aggregate_order_by {
  avg: topic_avg_order_by
  count: order_by
  max: topic_max_order_by
  min: topic_min_order_by
  stddev: topic_stddev_order_by
  stddev_pop: topic_stddev_pop_order_by
  stddev_samp: topic_stddev_samp_order_by
  sum: topic_sum_order_by
  var_pop: topic_var_pop_order_by
  var_samp: topic_var_samp_order_by
  variance: topic_variance_order_by
}

"""
input type for inserting array relation for remote table "topics"
"""
input topic_arr_rel_insert_input {
  data: [topic_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: topic_on_conflict
}

"""
aggregate avg on columns
"""
type topic_avg_fields {
  createdById: Float
  id: Float
  updatedById: Float
}

"""
order by avg() on columns of table "topics"
"""
input topic_avg_order_by {
  createdById: order_by
  id: order_by
  updatedById: order_by
}

"""
Boolean expression to filter rows from the table "topics". All fields are combined with a logical 'AND'.
"""
input topic_bool_exp {
  _and: [topic_bool_exp!]
  _not: topic_bool_exp
  _or: [topic_bool_exp!]
  createdAt: timestamptz_comparison_exp
  createdById: Int_comparison_exp
  id: Int_comparison_exp
  parentTopicIds: json_comparison_exp
  slug: String_comparison_exp
  title: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
  updatedById: Int_comparison_exp
  user: user_bool_exp
  userByUpdatedById: user_bool_exp
}

"""
unique or primary key constraints on table "topics"
"""
enum topic_constraint {
  """
  unique or primary key constraint
  """
  topics_pkey

  """
  unique or primary key constraint
  """
  topics_slug_key

  """
  unique or primary key constraint
  """
  topics_title_key
}

"""
input type for incrementing numeric columns in table "topics"
"""
input topic_inc_input {
  createdById: Int
  id: Int
  updatedById: Int
}

"""
input type for inserting data into table "topics"
"""
input topic_insert_input {
  createdAt: timestamptz
  createdById: Int
  id: Int
  parentTopicIds: json
  slug: String
  title: String
  updatedAt: timestamptz
  updatedById: Int
  user: user_obj_rel_insert_input
  userByUpdatedById: user_obj_rel_insert_input
}

"""
aggregate max on columns
"""
type topic_max_fields {
  createdAt: timestamptz
  createdById: Int
  id: Int
  slug: String
  title: String
  updatedAt: timestamptz
  updatedById: Int
}

"""
order by max() on columns of table "topics"
"""
input topic_max_order_by {
  createdAt: order_by
  createdById: order_by
  id: order_by
  slug: order_by
  title: order_by
  updatedAt: order_by
  updatedById: order_by
}

"""
aggregate min on columns
"""
type topic_min_fields {
  createdAt: timestamptz
  createdById: Int
  id: Int
  slug: String
  title: String
  updatedAt: timestamptz
  updatedById: Int
}

"""
order by min() on columns of table "topics"
"""
input topic_min_order_by {
  createdAt: order_by
  createdById: order_by
  id: order_by
  slug: order_by
  title: order_by
  updatedAt: order_by
  updatedById: order_by
}

"""
response of any mutation on the table "topics"
"""
type topic_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [topic!]!
}

"""
on conflict condition type for table "topics"
"""
input topic_on_conflict {
  constraint: topic_constraint!
  update_columns: [topic_update_column!]! = []
  where: topic_bool_exp
}

"""
Ordering options when selecting data from "topics".
"""
input topic_order_by {
  createdAt: order_by
  createdById: order_by
  id: order_by
  parentTopicIds: order_by
  slug: order_by
  title: order_by
  updatedAt: order_by
  updatedById: order_by
  user: user_order_by
  userByUpdatedById: user_order_by
}

"""
primary key columns input for table: topic
"""
input topic_pk_columns_input {
  id: Int!
}

"""
select columns of table "topics"
"""
enum topic_select_column {
  """
  column name
  """
  createdAt

  """
  column name
  """
  createdById

  """
  column name
  """
  id

  """
  column name
  """
  parentTopicIds

  """
  column name
  """
  slug

  """
  column name
  """
  title

  """
  column name
  """
  updatedAt

  """
  column name
  """
  updatedById
}

"""
input type for updating data in table "topics"
"""
input topic_set_input {
  createdAt: timestamptz
  createdById: Int
  id: Int
  parentTopicIds: json
  slug: String
  title: String
  updatedAt: timestamptz
  updatedById: Int
}

"""
aggregate stddev on columns
"""
type topic_stddev_fields {
  createdById: Float
  id: Float
  updatedById: Float
}

"""
order by stddev() on columns of table "topics"
"""
input topic_stddev_order_by {
  createdById: order_by
  id: order_by
  updatedById: order_by
}

"""
aggregate stddev_pop on columns
"""
type topic_stddev_pop_fields {
  createdById: Float
  id: Float
  updatedById: Float
}

"""
order by stddev_pop() on columns of table "topics"
"""
input topic_stddev_pop_order_by {
  createdById: order_by
  id: order_by
  updatedById: order_by
}

"""
aggregate stddev_samp on columns
"""
type topic_stddev_samp_fields {
  createdById: Float
  id: Float
  updatedById: Float
}

"""
order by stddev_samp() on columns of table "topics"
"""
input topic_stddev_samp_order_by {
  createdById: order_by
  id: order_by
  updatedById: order_by
}

"""
aggregate sum on columns
"""
type topic_sum_fields {
  createdById: Int
  id: Int
  updatedById: Int
}

"""
order by sum() on columns of table "topics"
"""
input topic_sum_order_by {
  createdById: order_by
  id: order_by
  updatedById: order_by
}

"""
update columns of table "topics"
"""
enum topic_update_column {
  """
  column name
  """
  createdAt

  """
  column name
  """
  createdById

  """
  column name
  """
  id

  """
  column name
  """
  parentTopicIds

  """
  column name
  """
  slug

  """
  column name
  """
  title

  """
  column name
  """
  updatedAt

  """
  column name
  """
  updatedById
}

"""
aggregate var_pop on columns
"""
type topic_var_pop_fields {
  createdById: Float
  id: Float
  updatedById: Float
}

"""
order by var_pop() on columns of table "topics"
"""
input topic_var_pop_order_by {
  createdById: order_by
  id: order_by
  updatedById: order_by
}

"""
aggregate var_samp on columns
"""
type topic_var_samp_fields {
  createdById: Float
  id: Float
  updatedById: Float
}

"""
order by var_samp() on columns of table "topics"
"""
input topic_var_samp_order_by {
  createdById: order_by
  id: order_by
  updatedById: order_by
}

"""
aggregate variance on columns
"""
type topic_variance_fields {
  createdById: Float
  id: Float
  updatedById: Float
}

"""
order by variance() on columns of table "topics"
"""
input topic_variance_order_by {
  createdById: order_by
  id: order_by
  updatedById: order_by
}

"""
columns and relationships of "users"
"""
type user {
  """
  An array relationship
  """
  courses(
    """
    distinct select on columns
    """
    distinct_on: [course_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [course_order_by!]

    """
    filter the rows returned
    """
    where: course_bool_exp
  ): [course!]!

  """
  An array relationship
  """
  coursesByUpdatedById(
    """
    distinct select on columns
    """
    distinct_on: [course_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [course_order_by!]

    """
    filter the rows returned
    """
    where: course_bool_exp
  ): [course!]!

  """
  An aggregate relationship
  """
  coursesByUpdatedById_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [course_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [course_order_by!]

    """
    filter the rows returned
    """
    where: course_bool_exp
  ): course_aggregate!

  """
  An aggregate relationship
  """
  courses_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [course_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [course_order_by!]

    """
    filter the rows returned
    """
    where: course_bool_exp
  ): course_aggregate!
  createdAt: timestamptz!
  createdById: Int
  emailAddress: String
  firstName: String!
  fullName: String
  id: Int!
  lastActive: timestamptz
  lastName: String!

  """
  An array relationship
  """
  logins(
    """
    distinct select on columns
    """
    distinct_on: [activityLogin_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [activityLogin_order_by!]

    """
    filter the rows returned
    """
    where: activityLogin_bool_exp
  ): [activityLogin!]!

  """
  An aggregate relationship
  """
  logins_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [activityLogin_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [activityLogin_order_by!]

    """
    filter the rows returned
    """
    where: activityLogin_bool_exp
  ): activityLogin_aggregate!

  """
  An array relationship
  """
  pages(
    """
    distinct select on columns
    """
    distinct_on: [page_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_order_by!]

    """
    filter the rows returned
    """
    where: page_bool_exp
  ): [page!]!

  """
  An array relationship
  """
  pagesByCreatedById(
    """
    distinct select on columns
    """
    distinct_on: [page_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_order_by!]

    """
    filter the rows returned
    """
    where: page_bool_exp
  ): [page!]!

  """
  An aggregate relationship
  """
  pagesByCreatedById_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [page_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_order_by!]

    """
    filter the rows returned
    """
    where: page_bool_exp
  ): page_aggregate!

  """
  An aggregate relationship
  """
  pages_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [page_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [page_order_by!]

    """
    filter the rows returned
    """
    where: page_bool_exp
  ): page_aggregate!

  """
  An array relationship
  """
  posts(
    """
    distinct select on columns
    """
    distinct_on: [post_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [post_order_by!]

    """
    filter the rows returned
    """
    where: post_bool_exp
  ): [post!]!

  """
  An array relationship
  """
  postsByUpdatedById(
    """
    distinct select on columns
    """
    distinct_on: [post_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [post_order_by!]

    """
    filter the rows returned
    """
    where: post_bool_exp
  ): [post!]!

  """
  An aggregate relationship
  """
  postsByUpdatedById_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [post_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [post_order_by!]

    """
    filter the rows returned
    """
    where: post_bool_exp
  ): post_aggregate!

  """
  An aggregate relationship
  """
  posts_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [post_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [post_order_by!]

    """
    filter the rows returned
    """
    where: post_bool_exp
  ): post_aggregate!

  """
  An object relationship
  """
  profile: profile
  pronouns: String

  """
  An object relationship
  """
  role: role!
  roleId: Int!
  status: String!

  """
  fetch data from the table: "tags"
  """
  tags(
    """
    distinct select on columns
    """
    distinct_on: [tag_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_order_by!]

    """
    filter the rows returned
    """
    where: tag_bool_exp
  ): [tag!]!

  """
  An array relationship
  """
  tagsByUpdatedById(
    """
    distinct select on columns
    """
    distinct_on: [tag_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_order_by!]

    """
    filter the rows returned
    """
    where: tag_bool_exp
  ): [tag!]!

  """
  An aggregate relationship
  """
  tagsByUpdatedById_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_order_by!]

    """
    filter the rows returned
    """
    where: tag_bool_exp
  ): tag_aggregate!

  """
  An aggregate relationship
  """
  tags_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [tag_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [tag_order_by!]

    """
    filter the rows returned
    """
    where: tag_bool_exp
  ): tag_aggregate!

  """
  An array relationship
  """
  topics(
    """
    distinct select on columns
    """
    distinct_on: [topic_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [topic_order_by!]

    """
    filter the rows returned
    """
    where: topic_bool_exp
  ): [topic!]!

  """
  An array relationship
  """
  topicsByUpdatedById(
    """
    distinct select on columns
    """
    distinct_on: [topic_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [topic_order_by!]

    """
    filter the rows returned
    """
    where: topic_bool_exp
  ): [topic!]!

  """
  An aggregate relationship
  """
  topicsByUpdatedById_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [topic_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [topic_order_by!]

    """
    filter the rows returned
    """
    where: topic_bool_exp
  ): topic_aggregate!

  """
  An aggregate relationship
  """
  topics_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [topic_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [topic_order_by!]

    """
    filter the rows returned
    """
    where: topic_bool_exp
  ): topic_aggregate!
  updatedAt: timestamptz!
  updatedById: Int

  """
  An object relationship
  """
  user: user

  """
  An object relationship
  """
  userByUpdatedById: user
  username: String

  """
  An array relationship
  """
  users(
    """
    distinct select on columns
    """
    distinct_on: [user_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [user_order_by!]

    """
    filter the rows returned
    """
    where: user_bool_exp
  ): [user!]!

  """
  An array relationship
  """
  usersByUpdatedById(
    """
    distinct select on columns
    """
    distinct_on: [user_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [user_order_by!]

    """
    filter the rows returned
    """
    where: user_bool_exp
  ): [user!]!

  """
  An aggregate relationship
  """
  usersByUpdatedById_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [user_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [user_order_by!]

    """
    filter the rows returned
    """
    where: user_bool_exp
  ): user_aggregate!

  """
  An aggregate relationship
  """
  users_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [user_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [user_order_by!]

    """
    filter the rows returned
    """
    where: user_bool_exp
  ): user_aggregate!
  verified: Boolean!
}

"""
aggregated selection of "users"
"""
type user_aggregate {
  aggregate: user_aggregate_fields
  nodes: [user!]!
}

"""
aggregate fields of "users"
"""
type user_aggregate_fields {
  avg: user_avg_fields
  count(columns: [user_select_column!], distinct: Boolean): Int!
  max: user_max_fields
  min: user_min_fields
  stddev: user_stddev_fields
  stddev_pop: user_stddev_pop_fields
  stddev_samp: user_stddev_samp_fields
  sum: user_sum_fields
  var_pop: user_var_pop_fields
  var_samp: user_var_samp_fields
  variance: user_variance_fields
}

"""
order by aggregate values of table "users"
"""
input user_aggregate_order_by {
  avg: user_avg_order_by
  count: order_by
  max: user_max_order_by
  min: user_min_order_by
  stddev: user_stddev_order_by
  stddev_pop: user_stddev_pop_order_by
  stddev_samp: user_stddev_samp_order_by
  sum: user_sum_order_by
  var_pop: user_var_pop_order_by
  var_samp: user_var_samp_order_by
  variance: user_variance_order_by
}

"""
input type for inserting array relation for remote table "users"
"""
input user_arr_rel_insert_input {
  data: [user_insert_input!]!

  """
  on conflict condition
  """
  on_conflict: user_on_conflict
}

"""
aggregate avg on columns
"""
type user_avg_fields {
  createdById: Float
  id: Float
  roleId: Float
  updatedById: Float
}

"""
order by avg() on columns of table "users"
"""
input user_avg_order_by {
  createdById: order_by
  id: order_by
  roleId: order_by
  updatedById: order_by
}

"""
Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'.
"""
input user_bool_exp {
  _and: [user_bool_exp!]
  _not: user_bool_exp
  _or: [user_bool_exp!]
  courses: course_bool_exp
  coursesByUpdatedById: course_bool_exp
  createdAt: timestamptz_comparison_exp
  createdById: Int_comparison_exp
  emailAddress: String_comparison_exp
  firstName: String_comparison_exp
  fullName: String_comparison_exp
  id: Int_comparison_exp
  lastActive: timestamptz_comparison_exp
  lastName: String_comparison_exp
  logins: activityLogin_bool_exp
  pages: page_bool_exp
  pagesByCreatedById: page_bool_exp
  posts: post_bool_exp
  postsByUpdatedById: post_bool_exp
  profile: profile_bool_exp
  pronouns: String_comparison_exp
  role: role_bool_exp
  roleId: Int_comparison_exp
  status: String_comparison_exp
  tags: tag_bool_exp
  tagsByUpdatedById: tag_bool_exp
  topics: topic_bool_exp
  topicsByUpdatedById: topic_bool_exp
  updatedAt: timestamptz_comparison_exp
  updatedById: Int_comparison_exp
  user: user_bool_exp
  userByUpdatedById: user_bool_exp
  username: String_comparison_exp
  users: user_bool_exp
  usersByUpdatedById: user_bool_exp
  verified: Boolean_comparison_exp
}

"""
unique or primary key constraints on table "users"
"""
enum user_constraint {
  """
  unique or primary key constraint
  """
  users_email_key

  """
  unique or primary key constraint
  """
  users_pkey

  """
  unique or primary key constraint
  """
  users_username_key
}

"""
input type for incrementing numeric columns in table "users"
"""
input user_inc_input {
  createdById: Int
  id: Int
  roleId: Int
  updatedById: Int
}

"""
input type for inserting data into table "users"
"""
input user_insert_input {
  courses: course_arr_rel_insert_input
  coursesByUpdatedById: course_arr_rel_insert_input
  createdAt: timestamptz
  createdById: Int
  emailAddress: String
  firstName: String
  fullName: String
  id: Int
  lastActive: timestamptz
  lastName: String
  logins: activityLogin_arr_rel_insert_input
  pages: page_arr_rel_insert_input
  pagesByCreatedById: page_arr_rel_insert_input
  posts: post_arr_rel_insert_input
  postsByUpdatedById: post_arr_rel_insert_input
  profile: profile_obj_rel_insert_input
  pronouns: String
  role: role_obj_rel_insert_input
  roleId: Int
  status: String
  tags: tag_arr_rel_insert_input
  tagsByUpdatedById: tag_arr_rel_insert_input
  topics: topic_arr_rel_insert_input
  topicsByUpdatedById: topic_arr_rel_insert_input
  updatedAt: timestamptz
  updatedById: Int
  user: user_obj_rel_insert_input
  userByUpdatedById: user_obj_rel_insert_input
  username: String
  users: user_arr_rel_insert_input
  usersByUpdatedById: user_arr_rel_insert_input
  verified: Boolean
}

"""
aggregate max on columns
"""
type user_max_fields {
  createdAt: timestamptz
  createdById: Int
  emailAddress: String
  firstName: String
  fullName: String
  id: Int
  lastActive: timestamptz
  lastName: String
  pronouns: String
  roleId: Int
  status: String
  updatedAt: timestamptz
  updatedById: Int
  username: String
}

"""
order by max() on columns of table "users"
"""
input user_max_order_by {
  createdAt: order_by
  createdById: order_by
  emailAddress: order_by
  firstName: order_by
  fullName: order_by
  id: order_by
  lastActive: order_by
  lastName: order_by
  pronouns: order_by
  roleId: order_by
  status: order_by
  updatedAt: order_by
  updatedById: order_by
  username: order_by
}

"""
aggregate min on columns
"""
type user_min_fields {
  createdAt: timestamptz
  createdById: Int
  emailAddress: String
  firstName: String
  fullName: String
  id: Int
  lastActive: timestamptz
  lastName: String
  pronouns: String
  roleId: Int
  status: String
  updatedAt: timestamptz
  updatedById: Int
  username: String
}

"""
order by min() on columns of table "users"
"""
input user_min_order_by {
  createdAt: order_by
  createdById: order_by
  emailAddress: order_by
  firstName: order_by
  fullName: order_by
  id: order_by
  lastActive: order_by
  lastName: order_by
  pronouns: order_by
  roleId: order_by
  status: order_by
  updatedAt: order_by
  updatedById: order_by
  username: order_by
}

"""
response of any mutation on the table "users"
"""
type user_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [user!]!
}

"""
input type for inserting object relation for remote table "users"
"""
input user_obj_rel_insert_input {
  data: user_insert_input!

  """
  on conflict condition
  """
  on_conflict: user_on_conflict
}

"""
on conflict condition type for table "users"
"""
input user_on_conflict {
  constraint: user_constraint!
  update_columns: [user_update_column!]! = []
  where: user_bool_exp
}

"""
Ordering options when selecting data from "users".
"""
input user_order_by {
  coursesByUpdatedById_aggregate: course_aggregate_order_by
  courses_aggregate: course_aggregate_order_by
  createdAt: order_by
  createdById: order_by
  emailAddress: order_by
  firstName: order_by
  fullName: order_by
  id: order_by
  lastActive: order_by
  lastName: order_by
  logins_aggregate: activityLogin_aggregate_order_by
  pagesByCreatedById_aggregate: page_aggregate_order_by
  pages_aggregate: page_aggregate_order_by
  postsByUpdatedById_aggregate: post_aggregate_order_by
  posts_aggregate: post_aggregate_order_by
  profile: profile_order_by
  pronouns: order_by
  role: role_order_by
  roleId: order_by
  status: order_by
  tagsByUpdatedById_aggregate: tag_aggregate_order_by
  tags_aggregate: tag_aggregate_order_by
  topicsByUpdatedById_aggregate: topic_aggregate_order_by
  topics_aggregate: topic_aggregate_order_by
  updatedAt: order_by
  updatedById: order_by
  user: user_order_by
  userByUpdatedById: user_order_by
  username: order_by
  usersByUpdatedById_aggregate: user_aggregate_order_by
  users_aggregate: user_aggregate_order_by
  verified: order_by
}

"""
primary key columns input for table: user
"""
input user_pk_columns_input {
  id: Int!
}

"""
select columns of table "users"
"""
enum user_select_column {
  """
  column name
  """
  createdAt

  """
  column name
  """
  createdById

  """
  column name
  """
  emailAddress

  """
  column name
  """
  firstName

  """
  column name
  """
  fullName

  """
  column name
  """
  id

  """
  column name
  """
  lastActive

  """
  column name
  """
  lastName

  """
  column name
  """
  pronouns

  """
  column name
  """
  roleId

  """
  column name
  """
  status

  """
  column name
  """
  updatedAt

  """
  column name
  """
  updatedById

  """
  column name
  """
  username

  """
  column name
  """
  verified
}

"""
input type for updating data in table "users"
"""
input user_set_input {
  createdAt: timestamptz
  createdById: Int
  emailAddress: String
  firstName: String
  fullName: String
  id: Int
  lastActive: timestamptz
  lastName: String
  pronouns: String
  roleId: Int
  status: String
  updatedAt: timestamptz
  updatedById: Int
  username: String
  verified: Boolean
}

"""
aggregate stddev on columns
"""
type user_stddev_fields {
  createdById: Float
  id: Float
  roleId: Float
  updatedById: Float
}

"""
order by stddev() on columns of table "users"
"""
input user_stddev_order_by {
  createdById: order_by
  id: order_by
  roleId: order_by
  updatedById: order_by
}

"""
aggregate stddev_pop on columns
"""
type user_stddev_pop_fields {
  createdById: Float
  id: Float
  roleId: Float
  updatedById: Float
}

"""
order by stddev_pop() on columns of table "users"
"""
input user_stddev_pop_order_by {
  createdById: order_by
  id: order_by
  roleId: order_by
  updatedById: order_by
}

"""
aggregate stddev_samp on columns
"""
type user_stddev_samp_fields {
  createdById: Float
  id: Float
  roleId: Float
  updatedById: Float
}

"""
order by stddev_samp() on columns of table "users"
"""
input user_stddev_samp_order_by {
  createdById: order_by
  id: order_by
  roleId: order_by
  updatedById: order_by
}

"""
aggregate sum on columns
"""
type user_sum_fields {
  createdById: Int
  id: Int
  roleId: Int
  updatedById: Int
}

"""
order by sum() on columns of table "users"
"""
input user_sum_order_by {
  createdById: order_by
  id: order_by
  roleId: order_by
  updatedById: order_by
}

"""
update columns of table "users"
"""
enum user_update_column {
  """
  column name
  """
  createdAt

  """
  column name
  """
  createdById

  """
  column name
  """
  emailAddress

  """
  column name
  """
  firstName

  """
  column name
  """
  fullName

  """
  column name
  """
  id

  """
  column name
  """
  lastActive

  """
  column name
  """
  lastName

  """
  column name
  """
  pronouns

  """
  column name
  """
  roleId

  """
  column name
  """
  status

  """
  column name
  """
  updatedAt

  """
  column name
  """
  updatedById

  """
  column name
  """
  username

  """
  column name
  """
  verified
}

"""
aggregate var_pop on columns
"""
type user_var_pop_fields {
  createdById: Float
  id: Float
  roleId: Float
  updatedById: Float
}

"""
order by var_pop() on columns of table "users"
"""
input user_var_pop_order_by {
  createdById: order_by
  id: order_by
  roleId: order_by
  updatedById: order_by
}

"""
aggregate var_samp on columns
"""
type user_var_samp_fields {
  createdById: Float
  id: Float
  roleId: Float
  updatedById: Float
}

"""
order by var_samp() on columns of table "users"
"""
input user_var_samp_order_by {
  createdById: order_by
  id: order_by
  roleId: order_by
  updatedById: order_by
}

"""
aggregate variance on columns
"""
type user_variance_fields {
  createdById: Float
  id: Float
  roleId: Float
  updatedById: Float
}

"""
order by variance() on columns of table "users"
"""
input user_variance_order_by {
  createdById: order_by
  id: order_by
  roleId: order_by
  updatedById: order_by
}
